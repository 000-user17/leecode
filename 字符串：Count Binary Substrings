class Solution {
public:
//算法思想：对于一个串"00110011"而言，其包含的1和0连续且个数相等的子串包括01，0011，1100，10，01，0011六个，对于一个0000111而言，包含的满足条件的子串有min(0个数,1个数)。但是这样的子串在01变换交界处都要进行查找，因此只需要在每次0和1变化的起点位置如0011中记录1最初出现的位置，作为下一次开始的起点。
//时间复杂度O(n),空间O(1)
    int countBinarySubstrings(string s) {
        int n=s.size(), ans=0;
        int i=0, j=0, loc=0;
        while(i<n && j<n){
            while(j<n && s[i] == s[j]){ //先找到与起点位置相异的第一个字符位置
                ++j;
            }
            if(j==n) break; //如果到最后都没找到相异的字符，则直接退出，不增加ans
            loc = j;  //将该位置作为下一次的起点
            while(j<n && s[j] != s[i]){  //如果不等于起点位置的字符，则增加
                ++j;
            }
            ans+=min(loc-i, j-loc); //ans增加min(0的个数，1的个数)
            i = loc;  //从起点位置重新开始
            j = loc;
        }
        return ans;
    }
};
//也可以用一个数组记录每组0和1的个数，然后利用上述性质计算
