class Solution {
public:
/*dfs利用递归来写*/
    void dfs(vector<vector<int>> &grid, int i, int j, int &ans ){
        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size())
        return ;
        if(grid[i][j] >= 2 ) return ;
        if(grid[i][j] == 1 ){
            if(i-1 < 0) ans++;  //判断是否与边界外的水相连
            else if(grid[i-1][j] == 0 || grid[i-1][j]==2) ans++;
            if(i+1 >= grid.size()) ans++;
            else if(grid[i+1][j]==0 || grid[i+1][j]==2) ans++;
            if(j-1 < 0) ans++;
            else if(grid[i][j-1] == 0 || grid[i][j-1]==2) ans++;
            if(j+1 >= grid[i].size()) ans++;
            else if(grid[i][j+1] == 0 || grid[i][j+1] == 2) ans++;
            }
        if(grid[i][j] == 0)
            grid[i][j]=2;
        if(grid[i][j] == 1)
            grid[i][j] = 3;  //不能全部grid[i][j]=2,因为这样会导致水块无法重复进行运算
                             //也不能只对陆地块进行grid[i][j]=2,因为会导致上下两个谁快无限来回递归
                             //为了重复计算水块，只能分开赋值，再判断条件处把重复的水块值2也纳入判断
        dfs(grid,i-1,j,ans);
        dfs(grid,i+1,j,ans);
        dfs(grid,i,j-1,ans);
        dfs(grid,i,j+1,ans);
    }
    int islandPerimeter(vector<vector<int>>& grid) {
        /*判断是否超过界限，以及与多少个水相邻，与水或边界相邻则+1*/
        int ans=0;
        dfs(grid,0,0,ans);
        return ans;
    }
};

/*判断是否超过界限，以及与多少个水相邻，与水或边界相邻则+1*/
 /*       int ans=0;
        for(int i=0 ; i< grid.size() ; i++){
            for(int j=0 ; j<grid[i].size() ; j++){
                int c=0;
                if(grid[i][j] == 1 ){
                    if(i-1 < 0) c++;  //判断是否与边界外的水相连
                    else if(grid[i-1][j] == 0) c++;
                    if(i+1 >= grid.size()) c++;
                    else if(grid[i+1][j]==0) c++;
                    if(j-1 < 0) c++;
                    else if(grid[i][j-1] == 0) c++;
                    if(j+1 >= grid[i].size()) c++;
                    else if(grid[i][j+1] == 0) c++;
                }
                ans+=c;
            }
        }
        return ans;*/
